### 코딩시험

https://docs.google.com/document/d/1e6cwFiJhOI00ab8YEwlxTqulCH81xPrjh6cx_5KVgOs/edit


### 인터뷰

오고싶은 이유

- 빠르개 성장하는 집단에서 일하고 싶은 열망이 크다. 블로그에서 읽은 글을 보면 빠르게 성장하는 곳은 개발자로써 기술적인 도전을 많이 마주한다고 생각한다. 새로운 서비스를 런칭하거나 큰 트래픽을 경험해보고, 그와 동시에 단순히 시키는 일만 하는 것이 아니라 많은 의사결정을 하는데 있어서 내가 그 일원이 되고 싶다. 또한 front에서 많은 테스트코드가 있다는 것을 듣고 감명받았다. 회사 블로그에도 글이 많이 올라오는게 좋다. 회사에서 지속적으로 스터디를 하는 글을 보았다.

1분소개

- 개발자
  http://woowabros.github.io/woowabros/2018/04/15/developer-relations.html
  http://woowabros.github.io/woowabros/2017/03/20/spring.html

- 깃허브

### 자소서

배달의 민족에 대해 어떤 것을 아느냐 
- 배달의 민족
- 배민찬
- 우아한 js
- React native

개발자란? 
- 세상에 있는 문제를 컴퓨터를 사용해서 해결내는 직업
- 프론트앤드 개발자로써 구현을 잘해서 로딩속도를 줄이거나 ui/ux를 효과적으로 만들게 되면 유저의 시간을 1초라도 아끼게 된다. 혹은 이탈 고객을 막음으로써 그들의 시간과 노력을 헛수고로 만들지 않고 회사 입장에서도 수익을 얻게 된다.

살아가면서 가장 성취감을 느꼈던 적 

수능 9월 모의고사
얼마전에 남들이 거의 제출하지 못한 B+ 과제를 제출하고 칭찬받았을때 + 남에게 알려줄때
내가 만든 서비스를 다른 사람들이 사용할때 가장 행복함을 느꼇다.
- `code.plus`
- `iupc.me`
- `인하대학교 시간표`

자신을 개발자의 덕목을 들어서 소개해주세요.
- 부지런함
  1. 배운 것을 깃허브에 다 기록한다. 커밋 로그에 나와있다.
  2. 프로젝트를 진행하면서 모르는 놓치지 않으려고 하고 있다.
  3. 일요일날 javascript 스터디를 진행하면서 부족한 점을 채우려고 하고 있다.
- 소통
  1. 나이차이가 있어도 학교 친구들과 잘 지낸다. 동아리 활동도 하면서 이것저것 많이 배운다.
  2. 개발관련 일 말고도 다른 일을 해본 경험이 있다. 이때 경험이 도움이 많이 된다.
  3. 멘토링이나 교육 조교, 멋쟁이 사자처럼 활동을 하면서 다양한 도메인 지식을 가진 사람들과 만났다.
  4. 구체적인 예시가 안떠오름
- 도전정신
  1. 실패를 두려워 하지만 그때문에 선택을 미루지는 않는다.
  2. 살면서 많은 리스크 있는 선택을 하면서 여기까지 왔다. 도전정신은 충분히 가지고 있다.
  3. 지난번에 일했던 경험도 실패라고 생각한다. 더 많이 성장할 수 있는 회사를 찾아가고 싶다.


우아한형제들 지원동기
- 많이 사용하고 기술 블로그에 글이 많이 올라오는 것이 매우 좋았다.
- 빠르게 발전하는 회사가 개발자들에게도 기술적인 도전을 많이 줄 것 같다.

inside javascript
>  모든 함수의 부모 객체는 Function.prototype의 객체이다. 그리고 Function.prototype은 함수이다. 이렇게 될 경우 Function.prototype의 `__proto__`는 Function.prototype이어야 하지만 Function.prototype의 `__proto__`는 Object.prototype을 가르키고 있다. 왜냐하면 ECMAScript의 명세서에는 예외적으로 Function.prototype의 객체 부모를 Object.prototype이라고 정의하고 있다.

javascript for web developer
  1. 객체 리터럴 방식인데 -> 이럴경우 메모리도 다시 만들어야 하고 그럼
  2. 프로토타입 체이닝 방식 -> 이럴경우 메서드는 공유 가능하지만 프로퍼티의 value가 레퍼런스일 경우 공유됨
  3. 프로토타입 체이닝 + 생성자 훔치기 

문재해결기법
  - 처음에는 최단거리 문제를 해결하기 위해서 다익스트라 알고리즘을 설명합니다. 그리고 간단하게 풀 수 잇는 문제를 알려줍니다.
  - 이를 응용한 문제를 냅니다. 소방차 문제인데, 가상의 노드와 엣지를 만들어서 다익스트라 알고리즘을 변형해서 문제를 해결할 수 있습니다.
  - 다익스트라의 한계점에 대해서 말합니다. 다익스트라의 경우 음수 가중치나 싸이클이 없으면 제대로 동작하지 않습니다. pq를 사용할 경우 음수 가중치가 있을 경우 동작하긴 하지만 그건 이미 다익스트라가 아닙니다.
  - 이때 벨만포드 알고리즘을 사용해서 문제를 해결할 수 있습니다.

### OOP

우선 우리가 프로그래밍을 하는 환경을 생각해보자. 하나의 프로젝트를 조낸 많은 사람들이 함께 개발한다. 또한 개발비용보다 유지비용이 큰 개발을 하게 된다(개발을 그렇게 한다는 의미가 아니라 유지 비용이 실제로 많이 든다는 뜻). 그럼 많은 사람들이 함께 개발할 때 어떻게 하는 게 편한지 유지 비용을 적게 하는 개발이 좋은 개발이겠네?

그래 그러면 OOP가 이러한 특징을 충족 시키는 지 확인해보자. 하면서 등장하는게 캡슐화, 다형성, 상속성 이죠. 이 특징에 대해서 오버로딩, 오버라이딩, 상속 등등 특징을 이야기 해주면서 유지 보수의 비용이 줄어들고 객체를 통해 많은 사람들이 코드를 모듈화 함으로써 일의 분배가 쉬워져 좀더 직관적으로 할 수 있다고 얘기합니다.

그럼 이제 정리만 하면되겠네요. 우리가 지금 개발하는 환경이 이러한데 OOP를 통해서 저러한 장점들을 얻을 수 있다고요. 그러면 쓰는 이유가 자연스럽게 설명되고 시간도 조낸 많이 가고 1석 2조네요!

### 쿠키 세션 스토리지

쿠키
유저가 웹 사이트에 방문했을때 서버가 사용자에 컴퓨터에 기록하는 정보이다. 주로 클라이언트에 대한 정보를 저장, 4kb의 용량한계, 별도의 암호화 부재, HTTP요청때마다 전송됨, 만료일이 존재, 높은 호환성

스토리지 : 큰 용량(5mb), 서버로 전송되지 않음, 클라이언트에 저장, 낮은 호환성, HTTP요청 때마다 호출되지는 않음.

세션
http 프로토콜에서 stateless한 상태를 statefull하게 만들어주는 데이터들이다. session은 주로 서버에 의해서 저장되며 
A session is a chunk of data maintained at the server that maintains state between HTTP requests. HTTP is fundamentally a stateless protocol; sessions are used to give it statefulness.

### 웹 브라우저에 URL창에 주소를 입력햇을때 일련과정을 설명하시오

1. 웹 브라우저에 URL을 입력한다.
2. DNS 서버로 URL을 전송하여 URL에 매칭되는 IP주소(포트번호)를 찾는다.
    2-1. 주로 DNS 서버는 ISP(Internet Service Provider)에 위치한다.
    2-2. 먼저 root 도메인 서버에 물어보고 .co.kr 이다 싶으면 .co.kr 도메인 서버에 물어본다. 그리고 서버위치를 전송해줘서 www 네임서버를 알려주고 www서버에 가 IP주소를 전송해 준다. 참조링크 : [https://opentutorials.org/course/559/2802](https://opentutorials.org/course/559/2802)

3. 서버에서 뭔가 뚝딱뚝딱 (프록시, 세션, 쿠키, 로드밸런싱 등등 요청 처리)
3. 서버에서 뭔가 뚝딱뚝딱
3. 서버에서 뭔가 뚝딱뚝딱

4. 페이지에 대한 응답으로 static 한 HTML, CSS, image, JS 등 한 파일들이 브라우저로 응답이 온다.
5. HTML DATA를 파싱한다. 파싱결과로 DOM tree를 만든다. 파싱 중 CSS가 들어오면 CSSOM(CSS Object Model)을 만든다.
6. 파싱결과로 나온 DOM Tree와 CSSOM을 이용하여 Render Tree를 만든다. 그리고 Layout을 잡은 뒤 print한다. 레이아웃을 잡는 것은 Render Tree가 잡힌 뒤이므로 브라우저가 resize가 되면 layout만 다시잡지 Render Tree를 다시 만들지는 않는다.


### Context Switching
Context Switch는 CPU에서 process를 switch할 때 발생하는 과정을 의미한다. 이때 이전 프로세스의 상태를 저장해서 종료를 해야하고 새로운 프로세스의 상태를 가지고 와서 로드를 해줘야하는데 이 때 상당한 오버헤드가 발생한다. 이유는 [Code - Data - Heap - Stack] 영역의 모든 메모리들가 모두 스위칭되어야 하기 때문이다. cpu는 한번에 하나의 프로세스만 실행가능


### Race Condition
같은 데이터에 동시 접근이 가능하게 되어 결과값이 특정 순서에 따라 달라질 수 있게 된 환경을 의미합니다
이렇게 공유 변수 접근에 가능한 영역을 Critical section이라 합니다.

### 쓰레드와 프로세스의 차이

프로세스(Process)
프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

스레드(Thread)
스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.

스택을 스레드마다 독립적으로 할당하는 이유
스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

* TCP(Transmission Control Protocol) : 연결형 서비스를 지원하는 전송계층 프로토콜, 호스트간 신뢰성 있는 데이터 전달과 흐름제어 및 혼잡제어 등을 제공하는 전송계층
  - 가상 회선 연결 방식, 연결형 서비스를 제공
  - 높은 신뢰성(Sequence Number, Ack Number를 통한 신뢰성 보장)
  - 데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(네트워크 내 패킷 수가 과도하게 증가하는 현상 방지)

* UDP(User Datagram Protocol)
  - 비연결형 서비스를 지원하는 전송계층 프로토콜
  - 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜
  - 비연결형(port만 확인하여 소켓을 식별하고 송수신)
  - 비신뢰성
  - 오류검출(헤더에 오류 검출 필드를 포함하여 무결성 검사)
  - UDP는 TCP와 달리 데이터의 수신에 대한 책임을 지지 않는다.